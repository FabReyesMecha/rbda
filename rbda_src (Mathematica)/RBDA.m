(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["RBDA`"]

createModelGeneral::usage="createModel[floatingBaseBool, noJoints, Units, parameters]: Create set of rules for model."
rx::usage = "rx[\[Theta]]: Basic 3D rotation around x-axis. Input '\[Theta]' is an angle."
ry::usage = "ry[\[Theta]]: Basic 3D rotation around y-axis. Input '\[Theta]' is an angle."
rz::usage = "rz[\[Theta]]: Basic 3D rotation around z-axis. Input '\[Theta]' is an angle."
rot::usage = "rot[plE]: General container for 6D rotations. Input 'plE' is a 3D rotation matrix."
rotx::usage = "rotx[\[Theta]]: Basic 6D rotation around x-axis. Input '\[Theta]' is an angle."
roty::usage = "roty[\[Theta]]: Basic 6D rotation around y-axis. Input '\[Theta]' is an angle."
rotz::usage = "rotz[\[Theta]]: Basic 6D rotation around z-axis. Input '\[Theta]' is an angle."
skew::usage = "skew[r]: Cross product operator (r\[Cross] pronounced r-cross). Input 'r' is either a 3D (point) vector or a skew-symmetric (3\[Cross]3) matrix."
xlt::usage = "xlt[r]: Translation transformation. Input 'r' is a three-dimensional vector."
pluX::usage = "pluX[plE,r]: General Plucker transformation for MOTION vectors. Input 'plE' is a 3D (or 6D) rotation matrix and 'r' is a 3D vector."
pluXf::usage = "pluXf[pluX] or pluXf[plE,r]: Plucker transformation for FORCE vectors. In the first case, input 'plE' is a 6x6 Plucker (motion) transformation. In the second case 'plE' is a 3D rotation matrix and 'r' is a translation vector."
coordinateTransform::usage="coordinateTransform[X,A,type,inputType]: Coordinate transformation (similarity or congruence). Input 'X' is a Plucker (motion) transformation, 'A' is the transformation to change, 'type' is either 'similarity' or 'congruence', and 'inputType' is either 'motion' or 'force'."
jcalc::usage = "jcalc[type,q]: Calculates Xj and S in body coordinates. Input 'type' is joint type (e.g., \"Rx\") and coordinate (either symbol or numerical value). Output: Plucker transformation Xj and motion subspace matrix S\[IndentingNewLine]For planr floating base (type=\"fbPlanar\"), the order of coordinates is [\[Theta],x,y]"
eulerRot::usage="Function not fully tested"
eulerJacobian::usage="Function not fully tested"
Xpts::usage= "Xpts[pluX, pts]: Transform points between coordinate frames. 'pts' can be a vector or a list of vectors. 'pluX' is a 6x6 Plucker transformation.\[IndentingNewLine]points 'pts' are expressed in reference frame A, and pluX is a transformation from frame A to B. Output is a list of points w.r.t. frame B."
forwardKinematics::usage = "forwardKinematics[model]: Automatic process to obtain all transformations from the inertial frame {0} to {\!\(\*SubscriptBox[\(B\), \(i\)]\)}. X0\[LeftDoubleBracket]i\[RightDoubleBracket]\!\(\*SuperscriptBox[\(=\), \(i\)]\)\!\(\*SubscriptBox[\(X\), \(0\)]\). invX0\[LeftDoubleBracket]i\[RightDoubleBracket]\!\(\*SuperscriptBox[\(=\), \(0\)]\)\!\(\*SubscriptBox[\(X\), \(i\)]\). Xup\[LeftDoubleBracket]i\[RightDoubleBracket]\!\(\*SuperscriptBox[\(=\), \(i\)]\)\!\(\*SubscriptBox[\(X\), \(\[Lambda] \((i)\)\)]\). bodyJ\[LeftDoubleBracket]i\[RightDoubleBracket]=[\!\(\*SubscriptBox[\(S\), \(1\)]\),\!\(\*SubscriptBox[\(S\), \(2\)]\),...,\!\(\*SubscriptBox[\(S\), \(i\)]\),...,0]. The geometric Jacobians of Body i represents the overall motion and not only the CoM (w.r.t. local coordinates). WARNING: Requires the global qVector to be previously defined"
DHParamsTranslator::usage="DHParamsTranslator[DHparams_?MatrixQ,floatingBaseBool_:False,floatingBaseType_:planar]:Translator of DH parameters to Plucker transformation. This function assumes the modified DH convention. The function is limited to planar open kinematic chains. The DHparams array must be in the order DHParams[[i]]:={\!\(\*SubscriptBox[\(\[Alpha]\), \(i\)]\),\!\(\*SubscriptBox[\(a\), \(i\)]\),\!\(\*SubscriptBox[\(d\), \(i\)]\),\!\(\*SubscriptBox[\(\[Upsilon]\), \(i\)]\)}."
crossM::usage = "crossM[v]: Spatial cross product for MOTION vectors. The input 'v' is a twist (either 3D or 6D)."
crossF::usage = "crossF[v]. Spatial cross product for FORCE vectors. The input 'v' is a twist (either 3D or 6D)."
inertiaTensor::usage= "inertiaTensor[params,type,connectivity]: Calculate inertia tensor of a body"
rbi::usage = "rbi[m,c, I]: RigidBodyInertia. m \[Epsilon] \[DoubleStruckCapitalR] is the mass, c \[Epsilon] \[DoubleStruckCapitalR]^3(\[Epsilon]\[DoubleStruckCapitalR]^2) is the position of the CoM, I\[Epsilon]\[DoubleStruckCapitalR]^(3\[Times]3)(\[Epsilon]\[DoubleStruckCapitalR]) is the rotational inertia around CoM"
contactConstraints::usage="contactConstraints[contactType]: Create spanning matrix T for forces and for free motions S. Assumes contact is in the y-direction of the local frame."
constrainedSubspace::usage="constrainedSubspace[constraintsInformation_,Jacobians_,\[Beta]_]: Output={A, \[Kappa]=\!\(\*OverscriptBox[\(A\), \(\[SmallCircle]\)]\)\!\(\*OverscriptBox[\(q\), \(\[SmallCircle]\)]\), \[Kappa]stab=\[Beta]A\!\(\*OverscriptBox[\(q\), \(\[SmallCircle]\)]\)}"
ID::usage="ID[model,q,qd,qdd,fex]: Calculates the inverse dynamics of a kinematic tree via the recursive Newton-Euler algorithm. q,qd and qdd are vectors of joint position,velocity and acceleration variables. fex is an optional argument, each row represents a wrench applied to each body (expressed w.r.t. the inerial frame). WARNING: Requires the global vectors qVector and dq to be previously defined."
HandC::usage="HandC[model,q,qd,fext,gravityTerms]: Coefficients of the eqns. of motion. gravityTerms is a boolean variable to decide if gravitational terms should be included in the output. Set as False if only Coriolis/centripetal effects are desired. WARNING: This function depends on the global variables qVector and dq."
FDcrb::usage="FDcrb[LOCALmodel, LOCALq, LOCALqd, tau, LOCALfext]: Composite-rigid-Body algorithm. Only works with numerical values."
FDab::usage=""
dimChange::usage=""

(*Public symbols*)
(*Symbol[#]&/@{t,m,mass,\[ScriptL],length,w,width,h,height,r,radius,Lx,comx,Ly,comy,Lz,comz,rbInertia,jtype,jointType};*)

Begin["`Private`"];

(*-------------------------------------------------------more general createModel function. It needs an array of parameters------------------------------------------------------------------------------*)
(*conInformation containts information about constraints*)
(*use Global` in front of symbols used in rules, to avoid complications of scope*)
createModelGeneral[floatingBaseBool_:False,noJoints_,units_:"[kg m s]",bodiesParams_,DHParameters_:{{0,0,0,0}},conInformation_:{}]:=Module[{model,DoF,nFB,bodies,bodiesRealQ,q,dotq,dotdotq,connectivity=True},
model={};

(*USER-defined values: floatingBase\[Rule]Boolean, nA=Integer*)
AppendTo[model,Global`floatingBase->floatingBaseBool];

(*nR: degrees of freedom (DoF) of the robot including the floating base (nFB). We have n-2 links (bodies) and n-nFB actuated joints*)
nFB:=Switch[Global`floatingBase/.model,True,3,False,0]; (*#non-actuated DoF of the floating base*)
DoF:=nFB+noJoints;
bodies:=Switch[Global`floatingBase/.model,True,noJoints+3,False,noJoints];(*I am considering the virtual bodies too*)
model=Join[model,{Global`nR->DoF,Global`nB->bodies,Global`nA->noJoints}];

(*Generalized coordinates and its derivatives*)
(*q=Switch[(floatingBase/.model),True,{Symbol["x"<>ToString[1]][t],Symbol["y"<>ToString[1]][t],Symbol["\[Theta]"<>ToString[1]][t]},False,{}];
q=If[noJoints\[NotEqual]0,q~Join~Array[Symbol["\[Phi]"<>ToString[#]][t]&,noJoints],q];*)
q=Switch[(Global`floatingBase/.model),True,{Subscript[Global`x, 1][Global`t],Subscript[Global`y, 1][Global`t],Subscript[Global`\[Theta], 1][Global`t]},False,{}];
q=If[noJoints!=0,q~Join~Array[Subscript[Global`\[Phi], #1][Global`t]&,noJoints],q];
dotq=\!\(
\*SubscriptBox[\(\[PartialD]\), \((Global`t)\)]q\);
dotdotq=\!\(
\*SubscriptBox[\(\[PartialD]\), \({Global`t, 2}\)]q\);

AppendTo[model,{Global`gc->q,Global`dgc->dotq,Global`ddgc->dotdotq}];
model=Flatten[model];

If[units=="[kg m s]",AppendTo[model,Global`g->9.80](*gravity acceleration [m/s^2]*)];
If[units=="[kg cm s]",AppendTo[model,Global`g->980](*gravity acceleration [cm/s^2]*)];
AppendTo[model,Global`inertialGrav->{0,0,0,0,-Global`g,0}];(*Gravity spatial force expressed in inertial frame. Assume it is in the y-axis, negative direction*)

(*Check if there is connection*)
Check[SolidData[Entity["Solid","SolidCuboid"],"InertiaTensor"],connectivity=False];

(*Now the Array of the parameters enconded in bodiesParams={{m1,Length1,width1,height1,radius1},...,{}}*)
If[floatingBaseBool==False,
model=model~Join~Table[Subscript[Global`m, i]->Global`mass/.bodiesParams[[i]],{i,1,bodies}];(*Array of masses*)
model=model~Join~Table[Subscript[Global`\[ScriptL], i]->Global`length/.bodiesParams[[i]],{i,1,bodies}];(*Array of link's lengths*)
model=model~Join~Table[Subscript[Global`w, i]->Global`width/.bodiesParams[[i]],{i,1,bodies}];(*Array of link's widths*)
model=model~Join~Table[Subscript[Global`h, i]->Global`height/.bodiesParams[[i]],{i,1,bodies}];(*Array of link's heights*)
model=model~Join~Table[Subscript[Global`r, i]->Global`radius/.bodiesParams[[i]],{i,1,bodies}];(*Array of link's radius*)
model=model~Join~Table[Subscript[Global`Lx, i]->Global`comx/.bodiesParams[[i]],{i,1,bodies}];(*local x-coordinate of CoM*)
model=model~Join~Table[Subscript[Global`Ly, i]->Global`comy/.bodiesParams[[i]],{i,1,bodies}];(*local y-coordinate of CoM*)
model=model~Join~Table[Subscript[Global`Lz, i]->Global`comz/.bodiesParams[[i]],{i,1,bodies}];(*local z-coordinate of CoM*)
model=model~Join~Array[Subscript[Global`rbInertia, #1]->rbi[Subscript[Global`m, #1],{Subscript[Global`Lx, #1],Subscript[Global`Ly, #1],Subscript[Global`Lz, #1]},inertiaTensor[{Subscript[Global`m, #1],Subscript[Global`\[ScriptL], #1],Subscript[Global`w, #1],Subscript[Global`h, #1],Subscript[Global`r, #1]},Global`shape/.bodiesParams[[#1]],connectivity]]&,bodies];
model=model~Join~Array[Subscript[Global`jtype, #1]->Global`jointType/.bodiesParams[[#1]]&,noJoints];
,
model=model~Join~Array[Subscript[Global`m, #1]->0&,2]~Join~Table[Subscript[Global`m, i]->Global`mass/.bodiesParams[[i]],{i,3,bodies}];(*Array of masses*)
model=model~Join~Array[Subscript[Global`\[ScriptL], #1]->0&,2]~Join~Table[Subscript[Global`\[ScriptL], i]->Global`length/.bodiesParams[[i]],{i,3,bodies}];(*Array of link's lengths*)
model=model~Join~Array[Subscript[Global`w, #1]->0&,2]~Join~Table[Subscript[Global`w, i]->Global`width/.bodiesParams[[i]],{i,3,bodies}];(*Array of link's widths*)
model=model~Join~Array[Subscript[Global`h, #1]->0&,2]~Join~Table[Subscript[Global`h, i]->Global`height/.bodiesParams[[i]],{i,3,bodies}];
model=model~Join~Array[Subscript[Global`r, #1]->0&,2]~Join~Table[Subscript[Global`r, i]->Global`radius/.bodiesParams[[i]],{i,3,bodies}];(*Array of link's radius*)
model=model~Join~Array[Subscript[Global`Lx, #1]->0&,2]~Join~Table[Subscript[Global`Lx, i]->Global`comx/.bodiesParams[[i]],{i,3,bodies}];(*local x-coordinate of CoM*)
model=model~Join~Array[Subscript[Global`Ly, #1]->0&,2]~Join~Table[Subscript[Global`Ly, i]->Global`comy/.bodiesParams[[i]],{i,3,bodies}];(*local y-coordinate of CoM*)
model=model~Join~Array[Subscript[Global`Lz, #1]->0&,2]~Join~Table[Subscript[Global`Lz, i]->Global`comz/.bodiesParams[[i]],{i,3,bodies}];(*local z-coordinate of CoM*)
model=model~Join~Array[Subscript[Global`rbInertia, #1]->ConstantArray[0,{6,6}]&,2]~Join~Table[Subscript[Global`rbInertia, i]->rbi[Subscript[Global`m, i],{Subscript[Global`Lx, i],Subscript[Global`Ly, i],Subscript[Global`Lz, i]},inertiaTensor[{Subscript[Global`m, i],Subscript[Global`\[ScriptL], i],Subscript[Global`w, i],Subscript[Global`h, i],Subscript[Global`r, i]},Global`shape/.bodiesParams[[i]],connectivity]],{i,3,bodies}];
model=model~Join~{Subscript[Global`jtype, 1]->"Px",Subscript[Global`jtype, 2]->"Py",Subscript[Global`jtype,3]->"Rz"}~Join~Table[Subscript[Global`jtype, i]->Global`jointType/.bodiesParams[[i]],{i,4,bodies}];
];

(*(*I should try to do this externally next*)
model=model~Join~{\[Mu]s\[Rule]0.1,Subscript[\[Mu]t, vis]\[Rule]0.03,Subscript[\[Mu]n, vis]\[Rule]0.3,Subscript[\[Mu]t, c]\[Rule]0.07,Subscript[\[Mu]n, c]\[Rule]0.7,\[Epsilon]\[Rule]0.1}; (*Several coefficients of friction*)*)

(*Model arrays*)
AppendTo[model,Global`parents->Array[(#1-1)&,bodies]];(*This represents a serial chain*)
bodiesRealQ:=Switch[floatingBaseBool,True,Array[False&,nFB-1]~Join~Array[True&,noJoints+1],False,Array[True&,noJoints]];
AppendTo[model,Global`bodiesReal->bodiesRealQ];
AppendTo[model, Global`DHParams->DHParameters];

Do[AppendTo[model,Subscript[Global`XT, i]->xlt[Global`xt/.bodiesParams[[i]]]],{i,1,bodies}];

(*Add formula for the absolute angles to the model*)
AppendTo[model,Global`absAngles->Switch[floatingBaseBool,True,Table[Sum[q[[i]],{i,3,j}],{j,3,bodies}],False,Table[Sum[q[[i]],{i,1,j}],{j,1,bodies}]]];

model]

(*------------------------------------------------------------------------------------------*)
(*Basic functions for transformations between Plucker reference frames.Check table 2.2 p.23.*)

(*Basic 3D rotations. Input '\[Theta]' is an angle.*)
rx[\[Theta]_]:={{1,0,0},{0,Cos[\[Theta]],Sin[\[Theta]]},{0,-Sin[\[Theta]],Cos[\[Theta]]}};
ry[\[Theta]_]:={{Cos[\[Theta]],0,-Sin[\[Theta]]},{0,1,0},{Sin[\[Theta]],0,Cos[\[Theta]]}};
rz[\[Theta]_]:={{Cos[\[Theta]],Sin[\[Theta]],0},{-Sin[\[Theta]],Cos[\[Theta]],0},{0,0,1}};

(*General container for 6D rotations. Input is a 3D rotation matrix.*)
rot[plE_]:=ArrayFlatten[{{plE,0},{0,plE}}];

(*6D rotations. Input '\[Theta]' is an angle.*)
rotx[\[Theta]_]:=rot[rx[\[Theta]]];
roty[\[Theta]_]:=rot[ry[\[Theta]]];
rotz[\[Theta]_]:=rot[rz[\[Theta]]];

(*Cross product operator (r\[Cross] pronounced r-cross). Input 'r' is either a 3D (point) vector or a skew-symmetric (3x3) matrix.*)
skew[r_?ArrayQ]:=Module[{out},
If[Dimensions[r]=={3,3},
out=1/2*{r[[3,2]]-r[[2,3]],r[[1,3]]-r[[3,1]],r[[2,1]]-r[[1,2]]},
out={{0,-r[[3]],r[[2]]},{r[[3]],0,-r[[1]]},{-r[[2]],r[[1]],0}}
];

out];

(*Translation transformation. Input 'r' is a 3D vector*)
xlt[r_?ArrayQ]:=ArrayFlatten[{{IdentityMatrix[3],0},{-skew[r],IdentityMatrix[3]}}];

(*pluX[plE,r]: General Plucker transformation for MOTION vectors. Input 'plE' is a 3D (or 6D) rotation matrix and 'r' is a 3D vector.*)
pluX[plE_,r_]:=If[Dimensions[plE]=={3,3},rot[plE].xlt[r],plE.xlt[r]];

(*pluXf[pluX]: Plucker transformation for FORCE vectors. Input is a 6x6 Plucker (motion) transformation*)
pluXf[pluX_]:=ArrayFlatten[{{pluX[[1;;3,1;;3]],pluX[[4;;6,1;;3]]},{0,pluX[[1;;3,1;;3]]}}];

(*pluXf[plE,r]: General Plucker transform for FORCE vectors. 'plE' is a 3D rotation matrix and 'r' is a translation vector.*)
pluXf[plE_,r_]:=rot[plE].Transpose[Inverse[xlt[r]]];

(*Coordinate transformation. Similarity or congruence*)
(*TODO:CHECK!! similarity for transformation type motion seems to have an error*)
(*coordinateTransform[X_,A_,type_,inputType_]:=Module[{},
Switch[type,
"similarity",
Switch[inputType,"motion",X.A.Inverse[A]//Simplify,"force",pluXf[X].A.pluXf[Inverse[X]],_,Print["incorrect InputType"];Array[0&,{6,6}]]//Simplify,
"congruence",
Switch[inputType,"motion",pluXf[X].A.Inverse[X]//Simplify,"force",X.A.pluXf[Inverse[X]],_,Print["incorrect InputType"];Array[0&,{6,6}]]//Simplify,
_,
Print["incorrect type"];Array[0&,{6,6}]]
];*)

(*coordinateTransform[X,A,type,inputType]: Coordinate transformation (similarity or congruence). Input 'X' is a Plucker (motion) transformation, 'A' is the transformation to change, 'type' is either 'similarity' or 'congruence', and 'inputType' is either 'motion' or 'force'.*)
coordinateTransform[X_,A_,type_,inputType_]:=Module[{},
Switch[type,
"similarity",
Switch[inputType,"motion",X.A.Inverse[X]//Simplify,"force",pluXf[X].A.pluXf[Inverse[X]],_,Print["Incorrect InputType"];Array[0&,{6,6}]]//Simplify,
"congruence",
Switch[inputType,"motion",pluXf[X].A.Inverse[X]//Simplify,"force",X.A.pluXf[Inverse[X]],_,Print["Incorrect InputType"];Array[0&,{6,6}]]//Simplify,
_,
Print["Incorrect type"];Array[0&,{6,6}]]
];

(*jcalc[type,q]: Calculates Xj and S in body coordinates. Input 'type' is joint type (e.g., "Rx") and coordinate (either symbol or numerical value). Output: Plucker transformation Xj and motion subspace matrix S
For planr floating base (type="fbPlanar"), the order of coordinates is [\[Theta],x,y]*)
(*TODO: Finish 6DOF floating base*)
jcalc[type_:"Rz",q_]:=Module[{XJ,S},

Switch[type,
"Rx",XJ=rotx[q];S={1,0,0,0,0,0},
"Ry",XJ=roty[q];S={0,1,0,0,0,0},
"Rz",XJ=rotz[q];S={0,0,1,0,0,0},
"Px",XJ=xlt[{q,0,0}];S={0,0,0,1,0,0},
"Py",XJ=xlt[{0,q,0}];S={0,0,0,0,1,0},
"Pz",XJ=xlt[{0,0,q}];S={0,0,0,0,0,1},
"fb",XJ=pluX[a,b];S=Transpose[{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,1,0,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}],
"fbPlanar",XJ=pluX[rz[q[[1]]],{q[[2]],q[[3]],0}];S={{0,0,1,0,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0}}];

{XJ,S}];

(*Spherical joint (three rotations). typeRot is rotation type (e.g., zyx*)
eulerRot[angles_?ArrayQ,typeRot_, outputFrame_:"local"]:=Module[{rotation},

(*Build the rotation matrix, according to the type*)
rotation=Switch[ToLowerCase@typeRot,
"zyx",rotx[angles[[3]]].roty[angles[[2]]].rotz[angles[[1]]],
_,Array[0&,{6,6}]
];

(*Return the corresponding matrix, depending on the output frame*)
Switch[ToLowerCase@outputFrame,
"local",rotation,
"global",Transpose[rotation],
_,Print["ouputFrame not correct. Returning local transformation"];rotation]
]

(*Jacobian corresponding to a rotation matrix from a spherical joint*)
eulerJacobian[angles_?ArrayQ,typeRot_, outputFrame_:"local"]:=Module[{\[Alpha],\[Beta],\[Gamma],spanS,rots,rot},
\[Alpha]=angles[[1]];
\[Beta]=angles[[2]];
\[Gamma]=angles[[3]];

(*Obtain the spanning matrices for free subspace*)
Switch[ToLowerCase@typeRot,
"zyx",
spanS={jcalc["Rz",\[Alpha]][[2]],jcalc["Ry",\[Beta]][[2]],jcalc["Rx",\[Gamma]][[2]]};
rots={rotz[\[Alpha]],roty[\[Beta]],rotx[\[Gamma]]};
rot=rots[[1]];

(*Accumulate rotations and transform S into local coordinates*)
Do[rot=rots[[i]].rot;Do[spanS[[j]]=rots[[i]].spanS[[j]],{j,1,i-1}],{i,2,3}];

(*Change into columns*)
spanS=Transpose[spanS];

(*If the frame is the global, multiply by the total accumulated rotation matrix*)
spanS=Switch[ToLowerCase@outputFrame,
"local",spanS,"global",rot.spanS,_,Print["returning local"];spanS],
_,
spanS=Array[0&,{6,1}];
rots=Array[0&,{6,6}]
];

spanS]

(*Xpts[pluX, pts]: Transform points between coordinate frames. 'pts' can be a vector or a list of vectors. 'pluX' is a 6x6 Plucker transformation.
points 'pts' are expressed in reference frame A, and pluX is a transformation from frame A to B. Output is a list of points w.r.t. frame B*)
Xpts[pluX_?MatrixQ,pts_]:=Module[{newPoints,E,r,tempP},
E=pluX[[1;;3,1;;3]];(*Rotation component of pluX*)
r=-skew[Transpose[E].pluX[[4;;6,1;;3]]];(*Translation component of pluX*)

(*If pts is a vector jus transform it, otherwise map the transformation over the list pts*)
If[Length[Dimensions[pts]]==1,
newPoints=E.(pts-r),
tempP=Map[#1-r&,pts];
newPoints=Map[E.#1&,tempP]];

newPoints];

(*forwardKinematics[model]: Automatic process to obtain all transformations from the inertial frame {0} to {Subscript[B, i]}. X0\[LeftDoubleBracket]i\[RightDoubleBracket]=^iSubscript[X, 0]. invX0\[LeftDoubleBracket]i\[RightDoubleBracket]=^0Subscript[X, i]. Xup\[LeftDoubleBracket]i\[RightDoubleBracket]=^iSubscript[X, \[Lambda](i)]. bodyJ\[LeftDoubleBracket]i\[RightDoubleBracket]=[Subscript[S, 1],Subscript[S, 2],...,Subscript[S, i],...,0]*)
(*The geometric Jacobians of Body i represents the overall motion and not only the CoM (w.r.t. local coordinates). WARNING: Requires the global qVector to be previously defined*)
forwardKinematics[model_]:=Module[{XJ,S,tempS,parentArray,Xup,X0,invX0,jacobian},

parentArray=Global`parents/.model;
Xup=Array[xup,Global`nB/.model];
S=Array[{0,0,0,0,0,0}&,Global`nB/.model];
X0=Array[ConstantArray[0,{6,6}]&,Global`nB/.model];
invX0=Array[ConstantArray[0,{6,6}]&,Global`nB/.model];
jacobian=Array[jac,Global`nB/.model];

Do[
{XJ,S[[i]]}=jcalc[Subscript[Global`jtype, i]/.model,Global`qVector[[i]]];
Xup[[i]]=XJ.(Subscript[Global`XT, i]/.model);

If[parentArray[[i]]==0,
X0[[i]]=Xup[[i]];
invX0[[i]]=Inverse[X0[[i]]],
X0[[i]]=Xup[[i]].X0[[i-1]]//Simplify;
invX0[[i]]=Inverse[X0[[i]]]//Simplify];

Do[S[[j]]=Xup[[i]].S[[j]],{j,1,i-1}];(*We change the previous S into local coordinates of Subscript[B, i]*)
jacobian[[i]]=Transpose[S]//Simplify;
,{i,1,Global`nB/.model}];

{Xup,X0,invX0,jacobian}];

(*Translator of DH parameters to Plucker transformation. This function assumes the modified DH convention. The function is limited to planar open kinematic chains*)
(*The DHparams array must be in the order DHParams[[i]]:={Subscript[\[Alpha], i],Subscript[a, i],Subscript[d, i],Subscript[\[Upsilon], i]}*)
(*TODO: Function not reviewed lately*)
DHParamsTranslator[DHparams_?MatrixQ,floatingBaseBool_:False,floatingBaseType_:"planar"]:=Module[{localXT},

localXT=ConstantArray[0,{nB/.model,6,6}];

(*Decide what to do based on floatingBaseBool and floatingBaseType*)
Switch[
floatingBaseBool,(*If there is no floating base, translate the DH parameters directly*)
False,
Print["no floating base"];
Do[localXT[[i]]=xlt[{DHparams[[i,2]],0,0}],{i,1,nB/.model}],
True,(*If there is a floating base, use the DHparams*)
Switch[
floatingBaseType,
"spatial",
Print["spatial floating base"],
"planar",
Print["planar floating base"];
localXT[[1]]=xlt[{0,0,0}];
localXT[[2]]=xlt[{0,0,0}];
localXT[[3]]=xlt[{0,0,0}];
Do[localXT[[i]]=xlt[{DHparams[[i,2]],0,0}],{i,4,nB/.model}]
]
];(*End of Switch*)

localXT];

(*----------------------------------------------------------------------------------------------------------------------------------*)
(*Spatial Vector Arithmetic*)

(*crossM[v]: Spatial cross product for MOTION vectors. The input 'v' is a twist (either 3D or 6D).*)
crossM[v_]:=Module[{out},

If[Dimensions[v]=={6},
out=ArrayFlatten[{{skew[v[[1;;3]]],0},{skew[v[[4;;6]]],skew[v[[1;;3]]]}}],
out={{0,0,0},{v[[3]],0,-v[[1]]},{-v[[2]],v[[1]],0}}];

out];

(*crossF[v]. Spatial cross product for FORCE vectors. The input 'v' is a twist (either 3D or 6D).*)
crossF[v_]:=-Transpose[crossM[v]];

(*inertiaTensor[params,type,connectivity]: Calculate inertia tensor of a body*)
(*Assume input is an array of parameters in the form: params={mass, l, w, h, r} and type is a string (e.g., "SolidCylinder")*)
(*l:= length along x     w:= length along y     h:= length along z      r:=radius*)
inertiaTensor[params_,type_:"prism",connectivity_:False]:=Module[{inertiaT,mass,length,width,height,radius},

mass=params[[1]];
length=params[[2]];
width=params[[3]];
height=params[[4]];
If[Length[params]==5,radius=params[[5]],radius=0];

(*If there is connectivity, use Wolfram database. Otherwise just calculate the tensors here*)
Switch[connectivity,
True,
inertiaT:=Switch[type,
"prism",SolidData[Entity["Solid","SolidCuboid"],"InertiaTensor"][length,width,height],
"cylinder",SolidData[Entity["Solid","SolidCylinder"],"InertiaTensor"][radius,height],
"verticalCylinder",SolidData[Entity["Solid","SolidCylinder"],"InertiaTensor"][radius,height],
"horizontalCylinder",(SolidData[Entity["Solid","SolidCylinder"],"InertiaTensor"][radius,height])[[{3,1,2},{3,1,2}]],
_,Print["shape not supported"];Array[0&,{3,3}]],
False,
Print["There is no connectivity"];
inertiaT:=Switch[type,
"prism",{{1/12 (height^2+width^2),0,0},{0,1/12 (height^2+length^2),0},{0,0,1/12 (length^2+width^2)}},
"cylinder",{{1/12 (height^2+3 radius^2),0,0},{0,1/12 (height^2+3 radius^2),0},{0,0,radius^2/2}},
"verticalCylinder",{{1/12 (height^2+3 radius^2),0,0},{0,1/12 (height^2+3 radius^2),0},{0,0,radius^2/2}},
"horizontalCylinder",{{radius^2/2,0,0},{0,1/12 (height^2+3 radius^2),0},{0,0,1/12 (height^2+3 radius^2)}},
_,Print["shape not supported"];Array[0&,{3,3}]]];

mass*inertiaT];

(*rbi[m,c, I]: RigidBodyInertia. m \[Epsilon] \[DoubleStruckCapitalR] is the mass, c \[Epsilon] \[DoubleStruckCapitalR]^3(\[Epsilon]\[DoubleStruckCapitalR]^2) is the position of the CoM, I\[Epsilon]\[DoubleStruckCapitalR]^(3\[Times]3)(\[Epsilon]\[DoubleStruckCapitalR]) is the rotational inertia around CoM*)
rbi[m_,c_,I_]:=Module[{out,skewC},
If[Dimensions[c]=={3},
skewC=skew[c];
out=ArrayFlatten[{{I+m*skewC.Transpose[skewC],m*skewC},{m*Transpose[skewC],m*IdentityMatrix[3]}}],
out={{I+m*Dot[c,c],-m*c[[2]],m*c[[1]]},{-m*c[[2]],m,0},{m*c[[1]],0,m}}];

out];

(*contactConstraints[contactType]: Create spanning matrix T for forces and for free motions S. Assumes contact is in the y-direction of the local frame.*)
contactConstraints[contactType_:"pointContactWithoutFriction",normalAxis_:"y"]:=Module[{T,S},

Switch[contactType,
"pointContactWithoutFriction",
T=Switch[ToLowerCase[normalAxis],"x",{{0,0,0,1,0,0}},"y",{{0,0,0,0,1,0}},"z",{{0,0,0,0,0,1}}];T=Transpose[T];
S=Switch[ToLowerCase[normalAxis],"x",Drop[1*IdentityMatrix[6],None,{4}],"y",Drop[1*IdentityMatrix[6],None,{5}],"z",Drop[1*IdentityMatrix[6],None,{6}]],
"planarHardContact",
T={{0,0},{0,0},{0,0},{1,0},{0,1},{0,0}};S=Drop[1*IdentityMatrix[6],None,{4,5}],
_,
Print["Contact type not supported"];T={{0}};S={{0}}];

{T,S}];

(*(*We always assume the snake robot is applying a force to the object/environment. Hence, the portion of A corresponding to the snake robot is -T^TbodyJ[[j]] *)
constrainedSubspace[constraintsInformation_,Jacobians_,\[Beta]_(*/;\[Beta]\[GreaterEqual]0*)]:=Module[{constraintMatrixA,derConstraintMatrixA,constrainedBody,contactPoint,contactingSide,\[Kappa],\[Kappa]stab,T,S,output},
constraintMatrixA={};
(*separate holonomic and non-holonomic constraints*)
Do[
constrainedBody=body/.constraintsInformation[[i]];
contactPoint=point/.constraintsInformation[[i]];
contactingSide=linkSide/.constraintsInformation[[i]];

Switch[constraintType/.constraintsInformation[[i]],
"joint",
(*TODO: I need the constraint at the position level*)
Null,
"non-slippage",
{T,S}=contactConstraints[contactModel/.constraintsInformation[[i]]];
AppendTo[constraintMatrixA,Transpose[T].xlt[contactPoint].Jacobians[[constrainedBody]]],
"non-slippageWithFriction",
{T,S}=contactConstraints[contactModel/.constraintsInformation[[i]]];
AppendTo[constraintMatrixA,Transpose[T].xlt[contactPoint].Jacobians[[constrainedBody]]],
"bodyContact",
{T,S}=contactConstraints[contactModel/.constraintsInformation[[i]]];
Switch[
contactingSide,
"left",AppendTo[constraintMatrixA,-Transpose[T].xlt[contactPoint].Jacobians[[constrainedBody]]],
"right",AppendTo[constraintMatrixA,-Transpose[T].pluX[rz[-180*Degree],contactPoint].Jacobians[[constrainedBody]]]],
_,
Print["constraint type on body "<>ToString[constrainedBody]<>" is not recognized"]],{i,1,Length[constraintsInformation]}];

constraintMatrixA=Flatten[constraintMatrixA,1]//Simplify;
derConstraintMatrixA=\!\(
\*SubscriptBox[\(\[PartialD]\), \(t\)]constraintMatrixA\);
\[Kappa]=derConstraintMatrixA.dq//Simplify;
\[Kappa]stab=\[Beta]*constraintMatrixA.dq//Simplify;

output={constraintMatrixA,\[Kappa],\[Kappa]stab}
]*)

(*Modified version that can be applied to both objects and robots. Assign the sign outside this function*)
(*The contactingSide information is w.r.t. the robot's link*)
(*We also create stabilization terms*)
constrainedSubspace[constraintsInformation_,Jacobians_,\[Beta]_(*/;\[Beta]\[GreaterEqual]0*),velocities_]:=Module[{constraintMatrixA,derConstraintMatrixA,constrainedBody,contactPoint,contactAngle,contactingSide,\[Kappa],\[Kappa]stab,T,S,output},

constraintMatrixA={};

(*separate holonomic and non-holonomic constraints*)
Do[
constrainedBody=Global`body/.constraintsInformation[[i]];(*Body of the robot where the constraint is located*)
contactPoint=Global`point/.constraintsInformation[[i]];(*Contact point in body's local coordinates*)
contactingSide=Global`linkSide/.constraintsInformation[[i]];(*Is the contact to the left or right of the link?*)
contactAngle=Global`angle/.constraintsInformation[[i]];(*Angle that the normal direction of the contact has w.r.t. the link*)

Switch[Global`constraintType/.constraintsInformation[[i]],
"joint",
Null(*TODO: I need the constraint at the position level*),
"non-slippage",
{T,S}=contactConstraints[Global`contactModel/.constraintsInformation[[i]]];
AppendTo[constraintMatrixA,Transpose[T].xlt[contactPoint].Jacobians[[constrainedBody]]],
"non-slippageWithFriction",
{T,S}=contactConstraints[Global`contactModel/.constraintsInformation[[i]]];
AppendTo[constraintMatrixA,Transpose[T].xlt[contactPoint].Jacobians[[constrainedBody]]],
"bodyContact",
{T,S}=contactConstraints[Global`contactModel/.constraintsInformation[[i]]];
Switch[
contactingSide,
"left",AppendTo[constraintMatrixA,Transpose[T].pluX[rz[contactAngle],contactPoint].Jacobians[[constrainedBody]]],
"right",AppendTo[constraintMatrixA,Transpose[T].pluX[rz[180*Degree+contactAngle],contactPoint].Jacobians[[constrainedBody]]]],
_,
Print["constraint type on body "<>ToString[constrainedBody]<>" is not recognized"]]
,{i,1,Length[constraintsInformation]}];

constraintMatrixA=Flatten[constraintMatrixA,1]//Simplify;
derConstraintMatrixA=\!\(
\*SubscriptBox[\(\[PartialD]\), \(t\)]constraintMatrixA\);
\[Kappa]=derConstraintMatrixA.velocities//Simplify;
\[Kappa]stab=\[Beta]*constraintMatrixA.velocities//Simplify;

output={constraintMatrixA,\[Kappa],\[Kappa]stab}]

(*ID[model,q,qd,qdd,fex]: Calculates the inverse dynamics of a kinematic tree via the recursive Newton-Euler algorithm. q,qd and qdd are vectors of joint position,velocity and acceleration variables*)
(*fex is an optional argument, each row represents a wrench applied to each body (expressed w.r.t. the inerial frame). WARNING: Requires the global vectors qVector and dq to be previously defined*)
(*TODO: This algorithm needs confirmation. Use the basic Lagrangian formulation for confirmation*)
ID[model_,q_,qd_,qdd_,fex_]:=Module[{dof,nBodies,tempConfiguration,XJ,S,vJ,Xup,parentArray,v,a,aGrav,f,X0,RBInertia,tau,fext=fex},

dof=Global`nR/.model;
nBodies=Global`nB/.model;

tempConfiguration=Join[Thread[Global`qVector->q],Thread[Global`dq->qd]];(*This works if either q is symbolic or numeric*)
S=Array[s,dof];
Xup=Array[xup,nBodies];
parentArray=Global`parents/.model;
v=Array[vel,nBodies];
a=Array[accel,nBodies];
f=Array[force,nBodies];
X0=Array[X0toi,nBodies];(*Transformations from body 0 to body i*)
tau=Array[jtorque,dof];
aGrav=Global`inertialGrav//.model;(*gravity in the inertial frame*)
(*If[fext\[Equal]Null,fext=Array[0&,{6,nBodies}]];(*In case there are no external forces, create an array of zeros*)*)
If[fext==Null,fext=Array[0&,{nBodies,6}]];(*In case there are no external forces, create an array of zeros*)

Do[
{XJ,S[[i]]}=jcalc[Subscript[Global`jtype, i]/.model,Global`qVector[[i]]]/.tempConfiguration;
vJ=S[[i]]*qd[[i]];
Xup[[i]]=XJ.Subscript[Global`XT, i]/.model;

If[parentArray[[i]]==0,
X0[[i]]=Xup[[i]];
v[[i]]=vJ;
a[[i]]=Xup[[i]].(-aGrav)+S[[i]]*qdd[[i]],
X0[[i]]=Xup[[i]].X0[[i-1]];
v[[i]]=Xup[[i]].v[[parentArray[[i]]]]+vJ;
a[[i]]=Xup[[i]].a[[parentArray[[i]]]]+S[[i]]*qdd[[i]]+crossM[v[[i]]].vJ];

RBInertia=Subscript[Global`rbInertia, i]//.model;
f[[i]]=RBInertia.a[[i]]+crossF[v[[i]]].RBInertia.v[[i]]-Transpose[Inverse[X0[[i]]]].fext[[i]];
,{i,1,nBodies}];

Do[
tau[[i]]=S[[i]].f[[i]];
If[parentArray[[i]]!=0,f[[parentArray[[i]]]]=f[[parentArray[[i]]]]+Transpose[Xup[[i]]].f[[i]]]
,{i,nBodies,1,-1}];

tau];

(*HandC[model,q,qd,fext,gravityTerms]: Coefficients of the eqns. of motion. gravityTerms is a boolean variable to decide if gravitational terms should be included in the output. Set as False if only Coriolis/centripetal effects are desired*)
(*WARNING: This function depends on the global variables qVector and dq*)
HandC[model_,q_,qd_,fex_,gravityTerms_:True]:=Module[{dof,nBodies,tempConfiguration,XJ,S,vJ,Xup,parentArray,v,avp,aGrav,fvp,X0,RBInertia,Cor,fext=fex,IC,H,fh,i,j},

dof=Global`nR/.model;
nBodies=Global`nB/.model;

tempConfiguration=Join[Thread[Global`qVector->q],Thread[Global`dq->qd]];(*This works if either q is symbolic or numeric*)

S=Array[s,dof];
Xup=Array[xup,nBodies];
parentArray=Global`parents/.model;
v=Array[vel,nBodies];
avp=Array[accel,nBodies];
fvp=Array[force,nBodies];
X0=Array[X0toi,nBodies];(*Transformations from body 0 to body i*)
(*aGrav=inertialGrav//.model;(*gravity in the inertial frame*)*)
aGrav:=Switch[gravityTerms,True,Global`inertialGrav//.model,False,{0,0,0,0,0,0}]; (*gravity in the inertial frame*)
Cor=Array[cor,nBodies];

(*If given a Null or empty list*)
If[fext==Null,fext=Array[0&,{nBodies,6}]];(*In case there are no external forces, create an array of zeros*)
If[Dimensions[fext]=={0},fext=Array[0&,{nBodies,6}]];(*In case there are no external forces, create an array of zeros*)

(*Calculation of Coriolis, centrifugal, and gravitational terms*)
Do[
{XJ,S[[i]]}=jcalc[Subscript[Global`jtype, i]/.model,Global`qVector[[i]]]/.tempConfiguration;
vJ=S[[i]]*qd[[i]];
Xup[[i]]=XJ.Subscript[Global`XT, i]/.model;

If[parentArray[[i]]==0,
X0[[i]]=Xup[[i]];
v[[i]]=vJ;
avp[[i]]=Xup[[i]].(-aGrav),
X0[[i]]=Xup[[i]].X0[[i-1]];
v[[i]]=Xup[[i]].v[[parentArray[[i]]]]+vJ;
avp[[i]]=Xup[[i]].avp[[parentArray[[i]]]]+crossM[v[[i]]].vJ];

RBInertia=Subscript[Global`rbInertia, i]//.model;
fvp[[i]]=RBInertia.avp[[i]]+crossF[v[[i]]].RBInertia.v[[i]]-Transpose[Inverse[X0[[i]]]].fext[[i]];
,{i,1,nBodies}];

Do[
Cor[[i]]=S[[i]].fvp[[i]];
If[parentArray[[i]]!=0,fvp[[parentArray[[i]]]]=fvp[[parentArray[[i]]]]+Transpose[Xup[[i]]].fvp[[i]]]
,{i,nBodies,1,-1}];

(*Composite inertia calculation. TODO: This may be filled in previous loop*)
IC=Array[inertiaComposite,nBodies];
Do[IC[[i]]=Subscript[Global`rbInertia, i]//.model,{i,1,nBodies}];

Do[
If[parentArray[[i]]!=0,
IC[[parentArray[[i]]]]=IC[[parentArray[[i]]]]+Transpose[Xup[[i]]].IC[[i]].Xup[[i]]]
,{i,nBodies,1,-1}];
Sow[IC];(*Gather the composite inertias with a reap*)

H=Array[0&,{nBodies,nBodies}];
Do[
fh=IC[[i]].S[[i]];
H[[i,i]]=S[[i]].fh;
j=i;

While[parentArray[[j]]>0,
fh=Transpose[Xup[[j]]].fh;
j=parentArray[[j]];
H[[i,j]]=S[[j]].fh;
H[[j,i]]=H[[i,j]]
](*End of while*)
,{i,1,nBodies}];

{H,Cor}];

(*FDcrb[LOCALmodel, LOCALq, LOCALqd, tau, LOCALfext]: Composite-rigid-Body algorithm. Only works with numerical values*)
FDcrb[LOCALmodel_,LOCALq_?(VectorQ[#,NumericQ]&),LOCALqd_?(VectorQ[#,NumericQ]&),tau_,LOCALfext_]:=Module[{LOCALH,LOCALCor,qdd,sol},

qdd=Array[Subscript[jaccel, #1]&,Global`nB/.LOCALmodel];
{LOCALH,LOCALCor}=HandC[LOCALmodel,LOCALq,LOCALqd,LOCALfext,True];
sol=Solve[Thread[LOCALH.qdd+LOCALCor==tau],qdd];

Flatten[qdd/.sol]];

(*REVIEW: Articulated-body algorithm*)
FDab[model_,q_,qd_,tau_,fex_,gravityTerms_:True]:=Module[{dof,nBodies,fext=fex,tempConfiguration,XJ,S,vJ,Xup,parentArray,v,c,aGrav,X0,IA,pA,U,d,u,Ia,pa,a,qdd},

dof=Global`nR/.model;
nBodies=Global`nB/.model;

tempConfiguration=Join[Thread[Global`qVector->q],Thread[Global`dq->qd]];(*This works if either q is symbolic or numeric*)

S=Array[s,dof];
Xup=Array[xup,nBodies];
parentArray=Global`parents/.model;
v=Array[vel,nBodies];
c=Array[cprod,nBodies];
X0=Array[X0toi,nBodies];(*Transformations from body 0 to body i*)
(*aGrav=inertialGrav//.model;(*gravity in the inertial frame*)*)
aGrav:=Switch[gravityTerms,True,Global`inertialGrav//.model,False,{0,0,0,0,0,0}]; (*gravity in the inertial frame*)
IA=Array[articulatedI,nBodies];
pA=Array[articulatedBias,nBodies];

(*If given a Null or empty list*)
If[fext==Null,fext=Array[0&,{nBodies,6}]];(*In case there are no external forces, create an array of zeros*)
If[Dimensions[fext]=={0},fext=Array[0&,{nBodies,6}]];(*In case there are no external forces, create an array of zeros*)

Do[
{XJ,S[[i]]}=jcalc[Subscript[Global`jtype, i]/.model,Global`qVector[[i]]]/.tempConfiguration;
vJ=S[[i]]*qd[[i]];
Xup[[i]]=XJ.Subscript[Global`XT, i]/.model;

If[parentArray[[i]]==0,
X0[[i]]=Xup[[i]];
v[[i]]=vJ;
c[[i]]={0,0,0,0,0,0},
X0[[i]]=Xup[[i]].X0[[i-1]];
v[[i]]=Xup[[i]].v[[parentArray[[i]]]]+vJ;
c[[i]]=crossM[v[[i]]].vJ];

IA[[i]]=Subscript[Global`rbInertia, i]//.model;
pA[[i]]=crossF[v[[i]]].IA[[i]].v[[i]]-Transpose[Inverse[X0[[i]]]].fext[[i]];
,{i,1,nBodies}];

(*2nd pass. Calculate articulated-body inertias*)
U=Array[articulatedU,nBodies];
d=Array[articulatedd,nBodies];
u=Array[articulatedu,nBodies];

Do[
U[[i]]=IA[[i]].S[[i]];
d[[i]]=S[[i]].U[[i]];
u[[i]]=tau[[i]]-S[[i]].pA[[i]];

If[parentArray[[i]]!=0,
Ia=IA[[i]]-1/d[[i]]*KroneckerProduct[U[[i]],U[[i]]];
pa=pA[[i]]+Ia.c[[i]]+1/d[[i]]*U[[i]]*u[[i]];
IA[[parentArray[[i]]]]=IA[[parentArray[[i]]]]+Transpose[Xup[[i]]].Ia.Xup[[i]];
pA[[parentArray[[i]]]]=pA[[parentArray[[i]]]]+Transpose[Xup[[i]]].pa
]
,{i,nBodies,1,-1}];

Sow[IA];
(*3rd pass. Calculate spatial accelerations*)
a=Array[accel,nBodies];
qdd=Array[Subscript[jaccel, #1]&,nBodies];

Do[
If[parentArray[[i]]==0,
a[[i]]=Xup[[i]].(-aGrav)+c[[i]],
a[[i]]=Xup[[i]].a[[parentArray[[i]]]]+c[[i]]
];

qdd[[i]]=1/d[[i]]*(u[[i]]-U[[i]].a[[i]]);
a[[i]]=a[[i]]+S[[i]]*qdd[[i]]
,{i,1,nBodies}];

qdd];

dimChange[quantity_]:=
Switch[Dimensions[quantity],
{6},quantity[[3;;5]],
{6,6},quantity[[3;;5,3;;5]],
{3},{0,0}~Join~quantity~Join~{0},
{3,3},ArrayFlatten[{{0,0,0,0},{0,0,0,0},{0,0,quantity,0},{0,0,0,0}}]
]

End[];
EndPackage[]
